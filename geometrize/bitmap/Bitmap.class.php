<?php

// Generated by Haxe 3.4.7
class geometrize_bitmap_Bitmap {
	public $width;
	public $height;
	public $data;

	public function __construct(){
		$this->data = new _hx_array(array());
	}

	public function getPixel($x, $y){
		return $this->data[$this->width*$y+$x];
	}

	public function setPixel($x, $y, $color){
		$this->data[$this->width*$y+$x] = $color;
	}

	public function hclone(){
		$bitmap = new geometrize_bitmap_Bitmap();
		$bitmap->width = $this->width;
		$bitmap->height = $this->height;
		$this1 = (new _hx_array(array()));
		$this1->length = $this->data->length;
		$bitmap->data = $this1;
		{
			$_g1 = 0;
			$_g = $this->data->length;
			while ($_g1<$_g){
				$_g1 = $_g1+1;
				$i = $_g1-1;
				$bitmap->data[$i] = $this->data[$i];
				unset($i);
			}
		}
		return $bitmap;
	}

	public function fill($color){
		$idx = 0;
		while ($idx<$this->data->length){
			$this->data[$idx] = $color;
			$idx++;
		}
	}

	public function __call($m, $a){
		if (isset($this->$m) && is_callable($this->$m)){
			return call_user_func_array($this->$m, $a);
		} else {
			if (isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m])){
				return call_user_func_array($this->__dynamics[$m], $a);
			} else {
				if ('toString'==$m){
					return $this->__toString();
				} else {
					throw new HException('Unable to call <' . $m . '>');
				}
			}
		}
	}


	public static function create($w, $h, $color){
		$bitmap = new geometrize_bitmap_Bitmap();
		$bitmap->width = $w;
		$bitmap->height = $h;
		$this1 = (new _hx_array(array()));
		$this1->length = $w*$h;
		$bitmap->data = $this1;
		$i = 0;
		while ($i<$bitmap->data->length){
			$bitmap->data[$i] = $color;
			$i = $i+1;
		}
		return $bitmap;
	}

	public static function createFromImageFile($file){
		list($w, $h) = getimagesize($file);
		$image = imagecreatefromstring(file_get_contents($file));

		$bitmap = new geometrize_bitmap_Bitmap();
		$bitmap->width = $w;
		$bitmap->height = $h;
		$bitmap->data->length = $w*$h;

		for ($x = 0; $x<$w; $x++){
			$l = $w * $h;
			for ($y = 0; $y<$h; $y++){
				// get a color
				$color_index = imagecolorat($image, $x, $y);
				// make it human readable
				$c = imagecolorsforindex($image, $color_index);
				$bitmap->data[$l+$x] = geometrize_bitmap_Bitmap::colorFromRGBAArray($c);
			}
		}

		return $bitmap;
	}

	public static function colorFromRGBAArray($c){
		if (isset($c['alpha'])){
			// in RGBA 0 = opaque, 127 = transparent
			// in geometrize 0 = transparent, 255 = opaque
			$c['alpha'] = round((127-$c['alpha'])*255/127);
		} else {
			$c['alpha'] = 255;
		}
		$color = ($c['red'] << 24) + ($c['green'] << 16) + ($c['blue'] << 8) + $c['alpha'];
		return $color;
	}


	function __toString(){
		return 'geometrize.bitmap.Bitmap';
	}
}
