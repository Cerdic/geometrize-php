<?php

// Generated by Haxe 3.4.7
class geometrize_State {
	public $shape;
	public $alpha;
	public $score;
	public $target;
	public $current;
	public $buffer;

	public function __construct($shape, $alpha, $target, $current, $buffer){
		if (!php_Boot::$skip_constructor){
			if (!($shape!==null)){
				throw new HException("FAIL: shape != null");
			}
			$this->shape = $shape;
			$this->alpha = $alpha;
			$this->score = -1;
			$this->target = $target;
			$this->current = $current;
			$this->buffer = $buffer;
		}
	}

	public function energy($lastScore, $bestScore = null){
		if ($this->score<0){
			$this->score = geometrize_Core::energy($this->shape, $this->alpha, $this->target, $this->current, $this->buffer, $lastScore, $bestScore);
		}
		return $this->score;
	}

	public function mutate(){
		$oldState = $this->hclone();
		$this->shape->mutate();
		// force score recomputing as we mutated
		$this->score = -1;
		return $oldState;
	}

	public function hclone(){
		$tmp = $this->shape->hclone();
		$newState = new geometrize_State($tmp, $this->alpha, $this->target, $this->current, $this->buffer);
		$newState->score = $this->score;
		return $newState;
	}

	public function __call($m, $a){
		if (isset($this->$m) && is_callable($this->$m)){
			return call_user_func_array($this->$m, $a);
		} else {
			if (isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m])){
				return call_user_func_array($this->__dynamics[$m], $a);
			} else {
				if ('toString'==$m){
					return $this->__toString();
				} else {
					throw new HException('Unable to call <' . $m . '>');
				}
			}
		}
	}

	function __toString(){
		return 'geometrize.State';
	}
}
