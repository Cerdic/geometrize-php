<?php

// Generated by Haxe 3.4.7
class geometrize_shape_QuadraticBezier implements geometrize_shape_Shape{
	public function __construct($xBound, $yBound) {
		if(!php_Boot::$skip_constructor) {
		$upper = $xBound - 1;
		if(!(0 <= $upper)) {
			throw new HException("FAIL: lower <= upper");
		}
		$this->x1 = mt_rand(0,$upper);
		$upper1 = $yBound - 1;
		if(!(0 <= $upper1)) {
			throw new HException("FAIL: lower <= upper");
		}
		$this->y1 = mt_rand(0,$upper1);
		$upper2 = $xBound - 1;
		if(!(0 <= $upper2)) {
			throw new HException("FAIL: lower <= upper");
		}
		$this->cx = mt_rand(0,$upper2);
		$upper3 = $yBound - 1;
		if(!(0 <= $upper3)) {
			throw new HException("FAIL: lower <= upper");
		}
		$this->cy = mt_rand(0,$upper3);
		$upper4 = $xBound - 1;
		if(!(0 <= $upper4)) {
			throw new HException("FAIL: lower <= upper");
		}
		$this->x2 = mt_rand(0,$upper4);
		$upper5 = $yBound - 1;
		if(!(0 <= $upper5)) {
			throw new HException("FAIL: lower <= upper");
		}
		$this->y2 = mt_rand(0,$upper5);
		$this->xBound = $xBound;
		$this->yBound = $yBound;
	}}
	public $cx;
	public $cy;
	public $x1;
	public $y1;
	public $x2;
	public $y2;
	public $xBound;
	public $yBound;
	public function rasterize() {
		$lines = (new _hx_array(array()));
		$points = (new _hx_array(array()));
		$pointCount = 20;
		{
			$_g1 = 0;
			$_g = $pointCount - 1;
			while($_g1 < $_g) {
				$_g1 = $_g1 + 1;
				$i = $_g1 - 1;
				$t = $i / $pointCount;
				$tp = 1 - $t;
				$x = intval($tp * ($tp * $this->x1 + $t * $this->cx) + $t * ($tp * $this->cx + $t * $this->x2));
				$y = intval($tp * ($tp * $this->y1 + $t * $this->cy) + $t * ($tp * $this->cy + $t * $this->y2));
				$points->push(_hx_anonymous(array("x" => $x, "y" => $y)));
				unset($y,$x,$tp,$t,$i);
			}
		}
		{
			$_g11 = 0;
			$_g2 = $points->length - 1;
			while($_g11 < $_g2) {
				$_g11 = $_g11 + 1;
				$i1 = $_g11 - 1;
				$p0 = $points[$i1];
				$p1 = $points[$i1 + 1];
				$pts = geometrize_rasterizer_Rasterizer::bresenham($p0->x, $p0->y, $p1->x, $p1->y);
				{
					$_g21 = 0;
					while($_g21 < $pts->length) {
						$point = $pts[$_g21];
						$_g21 = $_g21 + 1;
						$lines->push(new geometrize_rasterizer_Scanline($point->y, $point->x, $point->x));
						unset($point);
					}
					unset($_g21);
				}
				unset($pts,$p1,$p0,$i1);
			}
		}
		return geometrize_rasterizer_Scanline::trim($lines, $this->xBound, $this->yBound);
	}
	public function mutate() {
		if(!true) {
			throw new HException("FAIL: lower <= upper");
		}
		$r = mt_rand(0,2);
		switch($r) {
		case 0:{
			$value = $this->cx;
			if(!true) {
				throw new HException("FAIL: lower <= upper");
			}
			$value1 = $value + mt_rand(-8,+8);
			$max = $this->xBound - 1;
			if(!(0 <= $max)) {
				throw new HException("FAIL: min <= max");
			}
			$tmp = null;
			if($value1 < 0) {
				$tmp = 0;
			} else {
				if($value1 > $max) {
					$tmp = $max;
				} else {
					$tmp = $value1;
				}
			}
			$this->cx = $tmp;
			$value2 = $this->cy;
			if(!true) {
				throw new HException("FAIL: lower <= upper");
			}
			$value3 = $value2 + mt_rand(-8,+8);
			$max1 = $this->yBound - 1;
			if(!(0 <= $max1)) {
				throw new HException("FAIL: min <= max");
			}
			$tmp1 = null;
			if($value3 < 0) {
				$tmp1 = 0;
			} else {
				if($value3 > $max1) {
					$tmp1 = $max1;
				} else {
					$tmp1 = $value3;
				}
			}
			$this->cy = $tmp1;
		}break;
		case 1:{
			$value4 = $this->x1;
			if(!true) {
				throw new HException("FAIL: lower <= upper");
			}
			$value5 = $value4 + mt_rand(-8,+8);
			$max2 = $this->xBound - 1;
			if(!(1 <= $max2)) {
				throw new HException("FAIL: min <= max");
			}
			$tmp2 = null;
			if($value5 < 1) {
				$tmp2 = 1;
			} else {
				if($value5 > $max2) {
					$tmp2 = $max2;
				} else {
					$tmp2 = $value5;
				}
			}
			$this->x1 = $tmp2;
			$value6 = $this->y1;
			if(!true) {
				throw new HException("FAIL: lower <= upper");
			}
			$value7 = $value6 + mt_rand(-8,+8);
			$max3 = $this->yBound - 1;
			if(!(1 <= $max3)) {
				throw new HException("FAIL: min <= max");
			}
			$tmp3 = null;
			if($value7 < 1) {
				$tmp3 = 1;
			} else {
				if($value7 > $max3) {
					$tmp3 = $max3;
				} else {
					$tmp3 = $value7;
				}
			}
			$this->y1 = $tmp3;
		}break;
		case 2:{
			$value8 = $this->x2;
			if(!true) {
				throw new HException("FAIL: lower <= upper");
			}
			$value9 = $value8 + mt_rand(-8,+8);
			$max4 = $this->xBound - 1;
			if(!(1 <= $max4)) {
				throw new HException("FAIL: min <= max");
			}
			$tmp4 = null;
			if($value9 < 1) {
				$tmp4 = 1;
			} else {
				if($value9 > $max4) {
					$tmp4 = $max4;
				} else {
					$tmp4 = $value9;
				}
			}
			$this->x2 = $tmp4;
			$value10 = $this->y2;
			if(!true) {
				throw new HException("FAIL: lower <= upper");
			}
			$value11 = $value10 + mt_rand(-8,+8);
			$max5 = $this->yBound - 1;
			if(!(1 <= $max5)) {
				throw new HException("FAIL: min <= max");
			}
			$tmp5 = null;
			if($value11 < 1) {
				$tmp5 = 1;
			} else {
				if($value11 > $max5) {
					$tmp5 = $max5;
				} else {
					$tmp5 = $value11;
				}
			}
			$this->y2 = $tmp5;
		}break;
		}
	}
	public function rescale($scale) {
		$this->cx = intval(round($this->cx * $scale));
		$this->cy = intval(round($this->cy * $scale));
		$this->x1 = intval(round($this->x1 * $scale));
		$this->y1 = intval(round($this->y1 * $scale));
		$this->x2 = intval(round($this->x2 * $scale));
		$this->y2 = intval(round($this->y2 * $scale));
		$this->xBound = intval(round($this->xBound * $scale));
		$this->yBound = intval(round($this->yBound * $scale));
	}
	public function hclone() {
		$bezier = new geometrize_shape_QuadraticBezier($this->xBound, $this->yBound);
		$bezier->cx = $this->cx;
		$bezier->cy = $this->cy;
		$bezier->x1 = $this->x1;
		$bezier->y1 = $this->y1;
		$bezier->x2 = $this->x2;
		$bezier->y2 = $this->y2;
		if (isset($this->color)) {
			$bezier->color = $this->color;
		}
		return $bezier;
	}
	public function getType() {
		return 7;
	}
	public function getRawShapeData() {
		return (new _hx_array(array($this->x1, $this->y1, $this->cx, $this->cy, $this->x2, $this->y2)));
	}
	public function getSvgShapeData() {
		return "<path d=\"M" . _hx_string_rec($this->x1, "") . " " . _hx_string_rec($this->y1, "") . " Q " . _hx_string_rec($this->cx, "") . " " . _hx_string_rec($this->cy, "") . " " . _hx_string_rec($this->x2, "") . " " . _hx_string_rec($this->y2, "") . "\" " . _hx_string_or_null(geometrize_exporter_SvgExporter::$SVG_STYLE_HOOK) . " />";
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	function __toString() { return 'geometrize.shape.QuadraticBezier'; }
}
