<?php

// Generated by Haxe 3.4.7
class geometrize_shape_QuadraticBezier implements geometrize_shape_Shape {
	public $cx;
	public $cy;
	public $x1;
	public $y1;
	public $x2;
	public $y2;
	public $xBound;
	public $yBound;

	public function __construct($xBound, $yBound){
		if (!php_Boot::$skip_constructor){
			$upper = $xBound-1;
			if (!(0<=$upper)){
				throw new HException("FAIL: lower <= upper");
			}
			$this->x1 = mt_rand(0, $upper);
			$upper1 = $yBound-1;
			if (!(0<=$upper1)){
				throw new HException("FAIL: lower <= upper");
			}
			$this->y1 = mt_rand(0, $upper1);
			$upper2 = $xBound-1;
			if (!(0<=$upper2)){
				throw new HException("FAIL: lower <= upper");
			}
			$this->cx = mt_rand(0, $upper2);
			$upper3 = $yBound-1;
			if (!(0<=$upper3)){
				throw new HException("FAIL: lower <= upper");
			}
			$this->cy = mt_rand(0, $upper3);
			$upper4 = $xBound-1;
			if (!(0<=$upper4)){
				throw new HException("FAIL: lower <= upper");
			}
			$this->x2 = mt_rand(0, $upper4);
			$upper5 = $yBound-1;
			if (!(0<=$upper5)){
				throw new HException("FAIL: lower <= upper");
			}
			$this->y2 = mt_rand(0, $upper5);
			$this->xBound = $xBound;
			$this->yBound = $yBound;
		}
	}

	public function rasterize(){
		$lines = (new _hx_array(array()));
		$points = (new _hx_array(array()));
		$pointCount = 20;
		{
			$_g1 = 0;
			$_g = $pointCount-1;
			while ($_g1<$_g){
				$_g1 = $_g1+1;
				$i = $_g1-1;
				$t = $i/$pointCount;
				$tp = 1-$t;
				$x = intval($tp*($tp*$this->x1+$t*$this->cx)+$t*($tp*$this->cx+$t*$this->x2));
				$y = intval($tp*($tp*$this->y1+$t*$this->cy)+$t*($tp*$this->cy+$t*$this->y2));
				$points->push(_hx_anonymous(array("x" => $x, "y" => $y)));
				unset($y, $x, $tp, $t, $i);
			}
		}
		{
			$_g11 = 0;
			$_g2 = $points->length-1;
			while ($_g11<$_g2){
				$_g11 = $_g11+1;
				$i1 = $_g11-1;
				$p0 = $points[$i1];
				$p1 = $points[$i1+1];
				$pts = geometrize_rasterizer_Rasterizer::bresenham($p0->x, $p0->y, $p1->x, $p1->y);
				{
					$_g21 = 0;
					while ($_g21<$pts->length){
						$point = $pts[$_g21];
						$_g21 = $_g21+1;
						$lines->push(new geometrize_rasterizer_Scanline($point->y, $point->x, $point->x));
						unset($point);
					}
					unset($_g21);
				}
				unset($pts, $p1, $p0, $i1);
			}
		}
		return geometrize_rasterizer_Scanline::trim($lines, $this->xBound, $this->yBound);
	}

	public function mutate(){
		if (!true){
			throw new HException("FAIL: lower <= upper");
		}
		$r = mt_rand(0, 2);
		switch ($r) {
			case 0:
				{
					$value = $this->cx;
					if (!true){
						throw new HException("FAIL: lower <= upper");
					}
					$value1 = $value+mt_rand(-8, +8);
					$max = $this->xBound-1;
					if (!(0<=$max)){
						throw new HException("FAIL: min <= max");
					}
					$tmp = null;
					if ($value1<0){
						$tmp = 0;
					} else {
						if ($value1>$max){
							$tmp = $max;
						} else {
							$tmp = $value1;
						}
					}
					$this->cx = $tmp;
					$value2 = $this->cy;
					if (!true){
						throw new HException("FAIL: lower <= upper");
					}
					$value3 = $value2+mt_rand(-8, +8);
					$max1 = $this->yBound-1;
					if (!(0<=$max1)){
						throw new HException("FAIL: min <= max");
					}
					$tmp1 = null;
					if ($value3<0){
						$tmp1 = 0;
					} else {
						if ($value3>$max1){
							$tmp1 = $max1;
						} else {
							$tmp1 = $value3;
						}
					}
					$this->cy = $tmp1;
				}
				break;
			case 1:
				{
					$value4 = $this->x1;
					if (!true){
						throw new HException("FAIL: lower <= upper");
					}
					$value5 = $value4+mt_rand(-8, +8);
					$max2 = $this->xBound-1;
					if (!(1<=$max2)){
						throw new HException("FAIL: min <= max");
					}
					$tmp2 = null;
					if ($value5<1){
						$tmp2 = 1;
					} else {
						if ($value5>$max2){
							$tmp2 = $max2;
						} else {
							$tmp2 = $value5;
						}
					}
					$this->x1 = $tmp2;
					$value6 = $this->y1;
					if (!true){
						throw new HException("FAIL: lower <= upper");
					}
					$value7 = $value6+mt_rand(-8, +8);
					$max3 = $this->yBound-1;
					if (!(1<=$max3)){
						throw new HException("FAIL: min <= max");
					}
					$tmp3 = null;
					if ($value7<1){
						$tmp3 = 1;
					} else {
						if ($value7>$max3){
							$tmp3 = $max3;
						} else {
							$tmp3 = $value7;
						}
					}
					$this->y1 = $tmp3;
				}
				break;
			case 2:
				{
					$value8 = $this->x2;
					if (!true){
						throw new HException("FAIL: lower <= upper");
					}
					$value9 = $value8+mt_rand(-8, +8);
					$max4 = $this->xBound-1;
					if (!(1<=$max4)){
						throw new HException("FAIL: min <= max");
					}
					$tmp4 = null;
					if ($value9<1){
						$tmp4 = 1;
					} else {
						if ($value9>$max4){
							$tmp4 = $max4;
						} else {
							$tmp4 = $value9;
						}
					}
					$this->x2 = $tmp4;
					$value10 = $this->y2;
					if (!true){
						throw new HException("FAIL: lower <= upper");
					}
					$value11 = $value10+mt_rand(-8, +8);
					$max5 = $this->yBound-1;
					if (!(1<=$max5)){
						throw new HException("FAIL: min <= max");
					}
					$tmp5 = null;
					if ($value11<1){
						$tmp5 = 1;
					} else {
						if ($value11>$max5){
							$tmp5 = $max5;
						} else {
							$tmp5 = $value11;
						}
					}
					$this->y2 = $tmp5;
				}
				break;
		}
	}

	public function rescale($scale){
		$this->cx = intval(round($this->cx*$scale));
		$this->cy = intval(round($this->cy*$scale));
		$this->x1 = intval(round($this->x1*$scale));
		$this->y1 = intval(round($this->y1*$scale));
		$this->x2 = intval(round($this->x2*$scale));
		$this->y2 = intval(round($this->y2*$scale));
		$this->xBound = intval(round($this->xBound*$scale));
		$this->yBound = intval(round($this->yBound*$scale));
	}

	public function hclone(){
		$bezier = new geometrize_shape_QuadraticBezier($this->xBound, $this->yBound);
		$bezier->cx = $this->cx;
		$bezier->cy = $this->cy;
		$bezier->x1 = $this->x1;
		$bezier->y1 = $this->y1;
		$bezier->x2 = $this->x2;
		$bezier->y2 = $this->y2;
		if (isset($this->color)){
			$bezier->color = $this->color;
		}
		return $bezier;
	}

	public function getType(){
		return 7;
	}

	public function getRawShapeData(){
		return (new _hx_array(array($this->x1, $this->y1, $this->cx, $this->cy, $this->x2, $this->y2)));
	}

	public function getSvgShapeData(){
		return "<path d=\"M" . _hx_string_rec($this->x1, "") . " " . _hx_string_rec($this->y1, "") . " Q " . _hx_string_rec($this->cx, "") . " " . _hx_string_rec($this->cy, "") . " " . _hx_string_rec($this->x2, "") . " " . _hx_string_rec($this->y2, "") . "\" " . _hx_string_or_null(geometrize_exporter_SvgExporter::$SVG_STYLE_HOOK) . " />";
	}

	public function __call($m, $a){
		if (isset($this->$m) && is_callable($this->$m)){
			return call_user_func_array($this->$m, $a);
		} else {
			if (isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m])){
				return call_user_func_array($this->__dynamics[$m], $a);
			} else {
				if ('toString'==$m){
					return $this->__toString();
				} else {
					throw new HException('Unable to call <' . $m . '>');
				}
			}
		}
	}

	function __toString(){
		return 'geometrize.shape.QuadraticBezier';
	}
}
